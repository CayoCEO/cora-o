<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coração 3D – Bloom + Shader + Texto 3D</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#050510}
    #app{position:fixed;inset:0}
    .hint{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      font:14px system-ui;color:rgba(255,255,255,.75);
      background:rgba(0,0,0,.25);padding:8px 14px;border-radius:999px;
      backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.12);z-index:10
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Arraste para girar • Scroll/Pinça para zoom</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { FontLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js";
    import { TextGeometry } from "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js";

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const prefersReducedMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    // ---------- Scene / Camera / Renderer ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x050510, 4, 14);

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.01, 200);
    camera.position.set(0, 0.8, 6.4);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(2, devicePixelRatio));
    renderer.setClearColor(0x050510, 1);
    document.getElementById("app").appendChild(renderer.domElement);

    // OrbitControls (câmera livre)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.enablePan = true;
    controls.minDistance = 4.5;
    controls.maxDistance = 10.0;
    controls.target.set(0, 0.45, 0);

    // ---------- Postprocessing (Bloom) ----------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      isMobile ? 1.15 : 1.45,   // strength
      isMobile ? 0.55 : 0.65,   // radius
      0.0                       // threshold
    );
    composer.addPass(bloomPass);

    // ---------- Background stars (clean / deep) ----------
    (function addStars(){
      const starCount = isMobile ? 900 : 1600;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++){
        pos[i*3+0] = (Math.random()-0.5) * 60;
        pos[i*3+1] = (Math.random()-0.5) * 40;
        pos[i*3+2] = -Math.random() * 80;
      }
      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({
        size: 0.03,
        color: 0xffffff,
        transparent: true,
        opacity: 0.35,
        depthWrite: false
      });
      scene.add(new THREE.Points(geo, mat));
    })();

    // ---------- Heart math ----------
    function heart2D(t){
      return {
        x: 16 * Math.sin(t) ** 3,
        y: 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)
      };
    }

    // ---------- Heart geometry (more like print: strong contour) ----------
    function makeHeartParticles(count){
      const positions = new Float32Array(count * 3);
      const colors    = new Float32Array(count * 3);
      const sizes     = new Float32Array(count);

      const c1 = new THREE.Color("#ff006e");
      const c2 = new THREE.Color("#ff4fd8");

      for (let i = 0; i < count; i++){
        const t = Math.random() * Math.PI * 2;
        const p = heart2D(t);

        // MAIS contorno (quanto menor o expoente, mais “casca”)
        const r = Math.pow(Math.random(), 0.22);

        const x = p.x * (1 - r);
        const y = (p.y + 4) * (1 - r);
        const z = (Math.random() - 0.5) * 12 * (0.18 + (1 - r));

        positions[i*3+0] = x * 0.19;
        positions[i*3+1] = y * 0.19;
        positions[i*3+2] = z * 0.19;

        const mix = Math.random();
        const col = c1.clone().lerp(c2, mix);
        colors[i*3+0] = col.r;
        colors[i*3+1] = col.g;
        colors[i*3+2] = col.b;

        // tamanhos variáveis (mais “sparkle”)
        sizes[i] = (isMobile ? 10.0 : 12.0) * (0.65 + Math.random() * 0.7);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geo.setAttribute("aSize", new THREE.BufferAttribute(sizes, 1));
      return geo;
    }

    const heartCount = prefersReducedMotion ? 14000 : (isMobile ? 26000 : 56000);
    const heartGeo = makeHeartParticles(heartCount);

    // ---------- Custom Shader (glow particles) ----------
    const heartMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uPixelRatio: { value: Math.min(2, devicePixelRatio) },
        uBaseSize: { value: isMobile ? 4.3 : 4.8 }, // escala do gl_PointSize
      },
      vertexShader: `
        uniform float uTime;
        uniform float uPixelRatio;
        uniform float uBaseSize;
        attribute float aSize;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vGlow;

        void main(){
          vColor = color;

          vec3 p = position;

          // micro-tremor orgânico (bem sutil, estilo print)
          float n = sin(uTime*1.3 + p.x*2.2 + p.y*1.7) * 0.002;
          p += normalize(p) * n;

          // “glow factor” pela profundidade/altura
          vGlow = 0.6 + 0.4 * smoothstep(-0.5, 1.6, p.y);

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          // tamanho com atenuação por distância
          float dist = -mv.z;
          gl_PointSize = (uBaseSize * aSize * uPixelRatio) / max(1.0, dist);
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vGlow;

        void main(){
          // círculo suave
          vec2 uv = gl_PointCoord - vec2(0.5);
          float d = length(uv);

          // centro forte + borda glow
          float core = smoothstep(0.22, 0.0, d);
          float halo = smoothstep(0.55, 0.18, d);

          float a = (core*0.95 + halo*0.55) * vGlow;
          if(a < 0.02) discard;

          // puxa um pouco para “neon magenta”
          vec3 col = vColor;
          col.r = min(1.0, col.r * 1.15);
          col.b = min(1.0, col.b * 1.05);

          gl_FragColor = vec4(col, a);
        }
      `
    });

    const heart = new THREE.Points(heartGeo, heartMat);
    scene.add(heart);

    // ---------- Escape particles (spiral like print) ----------
    const escapeCount = isMobile ? 900 : 1900;
    const escapeGeo = new THREE.BufferGeometry();
    const ePos = new Float32Array(escapeCount * 3);
    const eData = new Array(escapeCount);

    for (let i = 0; i < escapeCount; i++){
      ePos[i*3+0] = (Math.random()-0.5) * 0.45;
      ePos[i*3+1] = (Math.random()-0.5) * 0.45;
      ePos[i*3+2] = (Math.random()-0.5) * 0.45;
      eData[i] = {
        a: Math.random() * Math.PI * 2,
        r: 0.15 + Math.random() * 0.55,
        v: 0.002 + Math.random() * 0.004
      };
    }
    escapeGeo.setAttribute("position", new THREE.BufferAttribute(ePos, 3));

    // escape usando o MESMO shader (mais parecido com print)
    const escapeMat = heartMat.clone();
    const escape = new THREE.Points(escapeGeo, escapeMat);
    escape.position.set(0, 0.05, 0);
    scene.add(escape);

    // ---------- Real 3D font (curved arc) ----------
    let textGroup = new THREE.Group();
    scene.add(textGroup);

    function buildCurved3DText(font, text){
      // limpa
      while (textGroup.children.length) textGroup.remove(textGroup.children[0]);

      const radius = 1.65;     // abraça o coração
      const y = 1.16;
      const total = text.length;

      const mat = new THREE.MeshBasicMaterial({
        color: 0xff4fd8,
        transparent: true,
        opacity: 0.95
      });

      for (let i = 0; i < total; i++){
        const ch = text[i] === " " ? " " : text[i];
        const geo = new TextGeometry(ch, {
          font,
          size: 0.12,
          height: 0.02,
          curveSegments: 6,
          bevelEnabled: true,
          bevelThickness: 0.005,
          bevelSize: 0.003,
          bevelSegments: 2
        });
        geo.computeBoundingBox();
        geo.center();

        const mesh = new THREE.Mesh(geo, mat);
        const angle = (i - (total-1)/2) * 0.18;

        mesh.position.set(Math.sin(angle) * radius, y, Math.cos(angle) * radius);
        mesh.lookAt(0, y - 0.15, 0);

        textGroup.add(mesh);
      }
    }

    // Load font (Three.js example font)
    const loader = new FontLoader();
    loader.load(
      "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json",
      (font) => buildCurved3DText(font, "Feliz Mês, Mi Vida")
    );

    // ---------- Animation ----------
    let beat = 0;
    const clock = new THREE.Clock();

    function animate(){
      const t = clock.getElapsedTime();
      heartMat.uniforms.uTime.value = t;
      escapeMat.uniforms.uTime.value = t + 10.0;

      // pulsação “musical”
      beat += 0.04;
      const pulse = 1 + Math.sin(beat) * 0.03;
      heart.scale.setScalar(pulse);

      // escape spiral (like print)
      const p = escapeGeo.attributes.position.array;
      for (let i = 0; i < escapeCount; i++){
        const d = eData[i];
        d.a += d.v * 6.0;

        p[i*3+0] = Math.cos(d.a) * d.r * 0.55;
        p[i*3+2] = Math.sin(d.a) * d.r * 0.55;
        p[i*3+1] += d.v * 10.5;

        if (p[i*3+1] > 1.8){
          p[i*3+1] = -0.7;
          d.a = Math.random() * Math.PI * 2;
          d.r = 0.15 + Math.random() * 0.55;
          d.v = 0.002 + Math.random() * 0.004;
        }
      }
      escapeGeo.attributes.position.needsUpdate = true;

      // texto gira bem sutil
      textGroup.rotation.y += 0.0017;

      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    // ---------- Resize ----------
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      bloomPass.setSize(innerWidth, innerHeight);
      heartMat.uniforms.uPixelRatio.value = Math.min(2, devicePixelRatio);
      escapeMat.uniforms.uPixelRatio.value = Math.min(2, devicePixelRatio);
    });
  </script>
</body>
</html>
