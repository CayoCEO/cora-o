<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Heart Scene – Print Style</title>
<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  background:#050510;
  overflow:hidden;
}
#app{position:fixed;inset:0}
.hint{
  position:fixed;
  left:50%;
  bottom:14px;
  transform:translateX(-50%);
  font:14px system-ui;
  color:rgba(255,255,255,.7);
  background:rgba(0,0,0,.25);
  padding:8px 14px;
  border-radius:999px;
  backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,.12);
  z-index:10
}
</style>
</head>
<body>

<div id="app"></div>
<div class="hint">Mouse: olhar • Scroll: zoom • WASD: mover • Q/E: subir/descer</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ================= CONFIG ================= */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x050510, 3, 16);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 300);
camera.position.set(0, 1, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setClearColor(0x050510, 1);
document.getElementById('app').appendChild(renderer.domElement);

/* ================= GLOW TEXTURE ================= */
function glowTexture(size=128){
  const c=document.createElement('canvas');
  c.width=c.height=size;
  const g=c.getContext('2d');
  const r=size/2;
  const grad=g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,'rgba(255,255,255,1)');
  grad.addColorStop(.35,'rgba(255,40,160,.9)');
  grad.addColorStop(.7,'rgba(255,0,120,.4)');
  grad.addColorStop(1,'rgba(255,0,120,0)');
  g.fillStyle=grad;
  g.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(c);
}
const glow = glowTexture();

/* ================= HEART MATH ================= */
function heart2D(t){
  return{
    x:16*Math.sin(t)**3,
    y:13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)
  };
}

/* ================= HEART ================= */
function createHeart(count){
  const pos=new Float32Array(count*3);
  const col=new Float32Array(count*3);
  const c1=new THREE.Color('#ff006e');
  const c2=new THREE.Color('#ff4fd8');

  for(let i=0;i<count;i++){
    const t=Math.random()*Math.PI*2;
    const p=heart2D(t);
    const r=Math.pow(Math.random(),0.18); // contorno forte

    const x=p.x*(1-r);
    const y=(p.y+4)*(1-r);
    const z=(Math.random()-.5)*12*(1-r); // volume igual em XYZ

    pos[i*3]=x*0.19;
    pos[i*3+1]=y*0.19;
    pos[i*3+2]=z*0.19;

    const c=c1.clone().lerp(c2,Math.random());
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  return{pos,col};
}

const heartCount = isMobile ? 28000 : 62000;
const heartData = createHeart(heartCount);

const heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute('position',new THREE.BufferAttribute(heartData.pos,3));
heartGeo.setAttribute('color',new THREE.BufferAttribute(heartData.col,3));

const heartMat = new THREE.PointsMaterial({
  size:isMobile?0.095:0.075,
  map:glow,
  transparent:true,
  vertexColors:true,
  blending:THREE.AdditiveBlending,
  depthWrite:false
});

const heart = new THREE.Points(heartGeo, heartMat);
scene.add(heart);

/* ================= FALLING PARTICLES ================= */
const rainCount = isMobile?1400:2800;
const rainGeo = new THREE.BufferGeometry();
const rainPos = new Float32Array(rainCount*3);

for(let i=0;i<rainCount;i++){
  rainPos[i*3]=(Math.random()-.5)*2.2;
  rainPos[i*3+1]=Math.random()*3.5+0.5;
  rainPos[i*3+2]=(Math.random()-.5)*2.2;
}
rainGeo.setAttribute('position',new THREE.BufferAttribute(rainPos,3));

const rain = new THREE.Points(
  rainGeo,
  new THREE.PointsMaterial({
    size:0.045,
    map:glow,
    transparent:true,
    blending:THREE.AdditiveBlending,
    opacity:.65,
    depthWrite:false,
    color:'#ff4fd8'
  })
);
scene.add(rain);

/* ================= TEXT RINGS (5) ================= */
function textRing(text,radius,y){
  const group=new THREE.Group();
  const chars=text.split('');
  chars.forEach((_,i)=>{
    const geo=new THREE.BoxGeometry(0.12,0.12,0.035);
    const mat=new THREE.MeshBasicMaterial({color:0xff4fd8});
    const mesh=new THREE.Mesh(geo,mat);
    const a=(i/chars.length)*Math.PI*2;
    mesh.position.set(Math.cos(a)*radius,y,Math.sin(a)*radius);
    mesh.lookAt(0,y,0);
    group.add(mesh);
  });
  return group;
}

const rings=[];
const ringTexts=[
  "EU TE AMO PARA SEMPRE",
  "VOCÊ É MEU MUNDO",
  "MINHA VIDA É VOCÊ",
  "PARA TODO O SEMPRE",
  "MEU CORAÇÃO É SEU"
];

ringTexts.forEach((txt,i)=>{
  const ring=textRing(txt,2.2+i*0.45,-0.8-i*0.35);
  ring.userData.speed=(i%2===0?1:-1)*(0.002-i*0.00025);
  rings.push(ring);
  scene.add(ring);
});

/* ================= CAMERA FREE MOVE ================= */
let yaw=0,pitch=0;
let move={f:0,b:0,l:0,r:0,u:0,d:0};
let dragging=false,lx=0,ly=0;

addEventListener('mousedown',e=>{dragging=true;lx=e.clientX;ly=e.clientY});
addEventListener('mousemove',e=>{
  if(!dragging)return;
  yaw-=(e.clientX-lx)*0.002;
  pitch-=(e.clientY-ly)*0.002;
  pitch=Math.max(-1.3,Math.min(1.3,pitch));
  lx=e.clientX;ly=e.clientY;
});
addEventListener('mouseup',()=>dragging=false);

addEventListener('keydown',e=>{
  if(e.key==='w')move.f=1;
  if(e.key==='s')move.b=1;
  if(e.key==='a')move.l=1;
  if(e.key==='d')move.r=1;
  if(e.key==='q')move.d=1;
  if(e.key==='e')move.u=1;
});
addEventListener('keyup',e=>{
  if(e.key==='w')move.f=0;
  if(e.key==='s')move.b=0;
  if(e.key==='a')move.l=0;
  if(e.key==='d')move.r=0;
  if(e.key==='q')move.d=0;
  if(e.key==='e')move.u=0;
});

/* ================= ANIMATE ================= */
let t=0;
function animate(){
  t+=0.04;

  heart.scale.setScalar(1+Math.sin(t)*0.03);

  // rain
  const rp=rainGeo.attributes.position.array;
  for(let i=0;i<rainCount;i++){
    rp[i*3+1]-=0.05;
    if(rp[i*3+1]<-2)rp[i*3+1]=Math.random()*3.5+0.5;
  }
  rainGeo.attributes.position.needsUpdate=true;

  // rings
  rings.forEach(r=>r.rotation.y+=r.userData.speed);

  // camera movement
  const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right=new THREE.Vector3(dir.z,0,-dir.x);
  camera.position.addScaledVector(dir,(move.f-move.b)*0.1);
  camera.position.addScaledVector(right,(move.r-move.l)*0.1);
  camera.position.y+=(move.u-move.d)*0.1;
  camera.rotation.set(pitch,yaw,0,'YXZ');

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

/* ================= RESIZE ================= */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
