<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Heart Scene – Final</title>
<style>
html,body{
  margin:0;
  padding:0;
  height:100%;
  background:#050510;
  overflow:hidden;
  touch-action:none;
}
#app{position:fixed;inset:0}
.hint{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  font:13px system-ui;
  color:rgba(255,255,255,.7);
  background:rgba(0,0,0,.25);
  padding:6px 12px;
  border-radius:999px;
  backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,.12);
  z-index:10
}
</style>
</head>
<body>

<div id="app"></div>
<div class="hint">Arraste • Pinça • WASD / Toque</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ================= CONFIG ================= */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x050510, 3, 18);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 300);
camera.position.set(0, 1, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setClearColor(0x050510, 1);
document.getElementById('app').appendChild(renderer.domElement);

/* ================= GLOW ================= */
function glowTexture(size=128){
  const c=document.createElement('canvas');
  c.width=c.height=size;
  const g=c.getContext('2d');
  const r=size/2;
  const grad=g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,'rgba(255,255,255,1)');
  grad.addColorStop(.4,'rgba(255,60,180,.9)');
  grad.addColorStop(.7,'rgba(255,0,120,.4)');
  grad.addColorStop(1,'rgba(255,0,120,0)');
  g.fillStyle=grad;
  g.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(c);
}
const glow = glowTexture();

/* ================= HEART ================= */
function heart2D(t){
  return{
    x:16*Math.sin(t)**3,
    y:13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)
  };
}

function createHeart(count){
  const pos=new Float32Array(count*3);
  const col=new Float32Array(count*3);
  const c1=new THREE.Color('#ff006e');
  const c2=new THREE.Color('#ff4fd8');

  for(let i=0;i<count;i++){
    const t=Math.random()*Math.PI*2;
    const p=heart2D(t);
    const r=Math.pow(Math.random(),0.22);

    const x=p.x*(1-r);
    const y=(p.y+4)*(1-r);
    const z=(Math.random()-.5)*(p.x*0.12)*(1-r);

    pos[i*3]=x*0.19;
    pos[i*3+1]=y*0.19;
    pos[i*3+2]=z*0.19;

    const c=c1.clone().lerp(c2,Math.random());
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  return{pos,col};
}

const heartCount = isMobile?24000:56000;
const heartData = createHeart(heartCount);

const heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute('position',new THREE.BufferAttribute(heartData.pos,3));
heartGeo.setAttribute('color',new THREE.BufferAttribute(heartData.col,3));

const heart = new THREE.Points(
  heartGeo,
  new THREE.PointsMaterial({
    size:isMobile?0.085:0.065,
    map:glow,
    transparent:true,
    vertexColors:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false
  })
);
scene.add(heart);

/* ================= TEXT RINGS (Canvas text) ================= */
function textSprite(text){
  const c=document.createElement('canvas');
  c.width=512; c.height=128;
  const g=c.getContext('2d');
  g.clearRect(0,0,c.width,c.height);
  g.font='64px Arial';
  g.textAlign='center';
  g.textBaseline='middle';
  g.fillStyle='#ff4fd8';
  g.shadowColor='#ff4fd8';
  g.shadowBlur=20;
  g.fillText(text,c.width/2,c.height/2);
  const tex=new THREE.CanvasTexture(c);
  return new THREE.SpriteMaterial({map:tex,transparent:true});
}

const rings=[];
const ringTexts=[
  "EU TE AMO PARA SEMPRE",
  "VOCÊ É MEU MUNDO",
  "MINHA VIDA É VOCÊ",
  "PARA TODO O SEMPRE",
  "MEU CORAÇÃO É SEU"
];

ringTexts.forEach((txt,i)=>{
  const group=new THREE.Group();
  const mat=textSprite(txt);
  const radius=2.2+i*0.45;
  const y=-0.9-i*0.35;

  for(let a=0;a<Math.PI*2;a+=Math.PI*2/24){
    const s=new THREE.Sprite(mat);
    s.scale.set(1.6,0.4,1);
    s.position.set(Math.cos(a)*radius,y,Math.sin(a)*radius);
    group.add(s);
  }
  group.userData.speed=(i%2? -1:1)*(0.002-i*0.00025);
  rings.push(group);
  scene.add(group);
});

/* ================= CAMERA CONTROLS ================= */
let yaw=0,pitch=0;
let velocity=new THREE.Vector3();
let dragging=false,lx=0,ly=0;
let touches=[];

/* mouse */
addEventListener('mousedown',e=>{dragging=true;lx=e.clientX;ly=e.clientY});
addEventListener('mousemove',e=>{
  if(!dragging)return;
  yaw-=(e.clientX-lx)*0.002;
  pitch-=(e.clientY-ly)*0.002;
  pitch=Math.max(-1.2,Math.min(1.2,pitch));
  lx=e.clientX;ly=e.clientY;
});
addEventListener('mouseup',()=>dragging=false);

/* touch */
addEventListener('touchstart',e=>touches=e.touches,{passive:true});
addEventListener('touchmove',e=>{
  if(e.touches.length===1){
    yaw-=(e.touches[0].clientX-lx)*0.003;
    pitch-=(e.touches[0].clientY-ly)*0.003;
  }
  if(e.touches.length===2){
    velocity.z-=0.02;
  }
  lx=e.touches[0].clientX;
  ly=e.touches[0].clientY;
},{passive:true});

/* keyboard */
const keys={};
addEventListener('keydown',e=>keys[e.key]=true);
addEventListener('keyup',e=>keys[e.key]=false);

/* ================= ANIMATE ================= */
let t=0;
function animate(){
  t+=0.04;
  heart.scale.setScalar(1+Math.sin(t)*0.03);

  rings.forEach(r=>r.rotation.y+=r.userData.speed);

  const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right=new THREE.Vector3(dir.z,0,-dir.x);

  if(keys.w) velocity.addScaledVector(dir,0.1);
  if(keys.s) velocity.addScaledVector(dir,-0.1);
  if(keys.a) velocity.addScaledVector(right,-0.1);
  if(keys.d) velocity.addScaledVector(right,0.1);
  if(keys.e) velocity.y+=0.1;
  if(keys.q) velocity.y-=0.1;

  camera.position.add(velocity);
  velocity.multiplyScalar(0.85);

  camera.rotation.set(pitch,yaw,0,'YXZ');

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

/* ================= RESIZE ================= */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
