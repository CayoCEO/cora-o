<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>Heart 3D – Hybrid Print Style</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#050510;touch-action:none}
  #app{position:fixed;inset:0}
  .hint{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    font:13px system-ui;color:rgba(255,255,255,.75);
    background:rgba(0,0,0,.25);padding:6px 12px;border-radius:999px;
    backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.12);z-index:10
  }
</style>
</head>
<body>
<div id="app"></div>
<div class="hint">PC: arraste p/ olhar • WASD mover • Q/E subir • Scroll zoom | Celular: esquerda anda • direita olha • 2 dedos sobe/desce</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* =========================
   CONFIG
========================= */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const container = document.getElementById('app');

const MOVE_ACCEL = isMobile ? 3.5 : 6.0;     // aceleração (menor = mais lento)
const MOVE_MAX   = isMobile ? 1.5 : 2.3;     // velocidade máx (unidades/s)
const MOVE_DAMP  = 6.5;                      // quanto desacelera
const LOOK_SENS  = isMobile ? 0.004 : 0.002; // sensibilidade do olhar

/* =========================
   SCENE / CAMERA / RENDER
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x050510, 6, 35);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 300);
camera.position.set(0, 1.2, 9);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setClearColor(0x050510, 1);
container.appendChild(renderer.domElement);

/* =========================
   LIGHTS (glossy heart)
========================= */
scene.add(new THREE.HemisphereLight(0xffffff, 0x12001a, 0.55));

const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(4, 6, 5);
scene.add(key);

const rim = new THREE.DirectionalLight(0xff5bd4, 0.9);
rim.position.set(-6, 2, -6);
scene.add(rim);

const sparkle = new THREE.PointLight(0xff4fd8, 1.4, 40);
sparkle.position.set(0, 2.2, 3.5);
scene.add(sparkle);

/* =========================
   GLOW SPRITE (particles)
========================= */
function glowTexture(size=256){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const g = c.getContext('2d');
  const r = size/2;
  const grad = g.createRadialGradient(r,r,0,r,r,r);
  grad.addColorStop(0,'rgba(255,255,255,1)');
  grad.addColorStop(.35,'rgba(255,80,200,.95)');
  grad.addColorStop(.7,'rgba(255,0,140,.45)');
  grad.addColorStop(1,'rgba(255,0,120,0)');
  g.fillStyle = grad;
  g.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  return tex;
}
const glowTex = glowTexture();

/* =========================
   HEART MESH (solid, glossy)
   - Shape heart + Extrude + Bevel
========================= */
function makeHeartMesh(){
  const x = 0, y = 0;
  const heartShape = new THREE.Shape();
  // Coração clássico (bem reconhecível)
  heartShape.moveTo(x + 0.0, y + 0.35);
  heartShape.bezierCurveTo(x + 0.0, y + 0.35, x - 0.45, y + 0.05, x - 0.45, y - 0.25);
  heartShape.bezierCurveTo(x - 0.45, y - 0.55, x - 0.10, y - 0.78, x + 0.0, y - 0.95);
  heartShape.bezierCurveTo(x + 0.10, y - 0.78, x + 0.45, y - 0.55, x + 0.45, y - 0.25);
  heartShape.bezierCurveTo(x + 0.45, y + 0.05, x + 0.0, y + 0.35, x + 0.0, y + 0.35);

  const geo = new THREE.ExtrudeGeometry(heartShape, {
    depth: 0.65,              // “gordinho” no Z
    bevelEnabled: true,
    bevelThickness: 0.18,
    bevelSize: 0.15,
    bevelSegments: 8,
    curveSegments: 32,
    steps: 1
  });

  geo.center();
  geo.rotateX(Math.PI);       // ponta pra baixo
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    color: 0xff3a86,           // rosa vivo
    roughness: 0.22,           // glossy
    metalness: 0.06,
    emissive: 0x2a0018,
    emissiveIntensity: 0.35
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.scale.setScalar(2.2);
  mesh.position.set(0, 1.2, 0);
  return mesh;
}
const heartMesh = makeHeartMesh();
scene.add(heartMesh);

/* =========================
   PARTICLES AROUND HEART (aura)
========================= */
function makeAura(count){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const col = new Float32Array(count*3);

  const c1 = new THREE.Color('#ff006e');
  const c2 = new THREE.Color('#ff4fd8');

  for(let i=0;i<count;i++){
    // Distribui em uma “concha” ao redor do coração (profundidade real)
    const u = Math.random();
    const v = Math.random();
    const theta = u * Math.PI * 2;
    const phi = Math.acos(2*v - 1);
    const r = 2.3 + Math.random()*1.2; // raio da aura

    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.cos(phi) * 0.75; // achata um pouco no vertical
    const z = r * Math.sin(phi) * Math.sin(theta);

    pos[i*3+0]=x;
    pos[i*3+1]=y + 1.2; // centraliza na altura do coração
    pos[i*3+2]=z;

    const c = c1.clone().lerp(c2, Math.random());
    col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));

  const mat = new THREE.PointsMaterial({
    size: isMobile ? 0.09 : 0.075,
    map: glowTex,
    transparent:true,
    opacity:0.85,
    vertexColors:true,
    blending: THREE.AdditiveBlending,
    depthWrite:false
  });

  return new THREE.Points(geo, mat);
}
const aura = makeAura(isMobile ? 7000 : 14000);
scene.add(aura);

/* =========================
   FALLING PARTICLES (from heart)
========================= */
function makeFalling(count){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const vel = new Float32Array(count);

  for(let i=0;i<count;i++){
    // Spawn perto do coração (topo/miolo)
    pos[i*3+0] = (Math.random()-0.5)*1.8;
    pos[i*3+1] = 2.2 + Math.random()*1.6;     // começa acima
    pos[i*3+2] = (Math.random()-0.5)*1.8;
    vel[i] = 0.6 + Math.random()*1.2;         // velocidade queda
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.userData.vel = vel;

  const mat = new THREE.PointsMaterial({
    size: isMobile ? 0.07 : 0.055,
    map: glowTex,
    transparent:true,
    opacity:0.65,
    color: 0xff4fd8,
    blending: THREE.AdditiveBlending,
    depthWrite:false
  });

  return new THREE.Points(geo, mat);
}
const falling = makeFalling(isMobile ? 1200 : 2400);
scene.add(falling);

/* =========================
   TEXT RINGS (5 rings, circular)
   - cache per character
========================= */
const charMatCache = new Map();
function charSpriteMaterial(ch){
  const key = ch + '|v1';
  if(charMatCache.has(key)) return charMatCache.get(key);

  const c = document.createElement('canvas');
  c.width = 128; c.height = 128;
  const g = c.getContext('2d');

  g.clearRect(0,0,c.width,c.height);
  g.font = 'bold 72px Arial';
  g.textAlign = 'center';
  g.textBaseline = 'middle';
  g.fillStyle = '#ff4fd8';
  g.shadowColor = '#ff4fd8';
  g.shadowBlur = 18;
  g.fillText(ch, c.width/2, c.height/2);

  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity: 0.95 });
  charMatCache.set(key, mat);
  return mat;
}

function buildRing(text, radius, y, countAround, scaleX, scaleY){
  const group = new THREE.Group();

  // cria sequência “contínua” repetindo a frase até preencher o círculo
  const base = text + " • ";
  let full = "";
  while(full.length < countAround) full += base;
  full = full.slice(0, countAround);

  for(let i=0;i<countAround;i++){
    const ch = full[i];
    const spr = new THREE.Sprite(charSpriteMaterial(ch));
    spr.scale.set(scaleX, scaleY, 1);

    const a = (i / countAround) * Math.PI * 2;
    spr.position.set(Math.cos(a)*radius, y, Math.sin(a)*radius);

    // sprites “apontam” para o centro do ring (não ficam retos)
    spr.lookAt(0, y, 0);
    group.add(spr);
  }
  return group;
}

const rings = [];
const ringTexts = [
  "EU TE AMO PARA SEMPRE",
  "VOCÊ É MEU MUNDO",
  "MINHA VIDA É VOCÊ",
  "PARA TODO O SEMPRE",
  "MEU CORAÇÃO É SEU"
];

for(let i=0;i<5;i++){
  const radius = 2.8 + i*0.55;
  const y = -0.2 - i*0.55; // bem separado
  const countAround = isMobile ? 90 : 120; // densidade do círculo
  const sx = isMobile ? 0.22 : 0.18;
  const sy = isMobile ? 0.22 : 0.18;

  const ring = buildRing(ringTexts[i], radius, y, countAround, sx, sy);
  ring.userData.speed = (i%2===0 ? 1 : -1) * (0.35 - i*0.05); // graus/s (convertido depois)
  rings.push(ring);
  scene.add(ring);
}

/* =========================
   BACKGROUND STARS (light)
========================= */
(function addStars(){
  const starCount = isMobile ? 700 : 1400;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(starCount*3);
  for(let i=0;i<starCount;i++){
    pos[i*3+0] = (Math.random()-0.5)*80;
    pos[i*3+1] = (Math.random()-0.5)*50;
    pos[i*3+2] = -Math.random()*120;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({
    size: 0.03, color: 0xffffff, transparent:true, opacity: 0.35, depthWrite:false
  });
  scene.add(new THREE.Points(geo, mat));
})();

/* =========================
   CONTROLS
   - Desktop: drag to look, WASD move, Q/E up/down, scroll zoom
   - Mobile:
      left side drag = move
      right side drag = look
      2 fingers = up/down
========================= */
let yaw = 0, pitch = 0;
let draggingMouse = false, mx=0, my=0;
const keys = {};
const vel = new THREE.Vector3();

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

addEventListener('mousedown', (e)=>{
  draggingMouse = true; mx = e.clientX; my = e.clientY;
});
addEventListener('mousemove', (e)=>{
  if(!draggingMouse) return;
  const dx = e.clientX - mx;
  const dy = e.clientY - my;
  mx = e.clientX; my = e.clientY;
  yaw   -= dx * LOOK_SENS;
  pitch -= dy * LOOK_SENS;
  pitch = clamp(pitch, -1.25, 1.25);
});
addEventListener('mouseup', ()=> draggingMouse=false);

// zoom desktop
addEventListener('wheel', (e)=>{
  camera.fov = clamp(camera.fov + e.deltaY*0.01, 35, 85);
  camera.updateProjectionMatrix();
},{passive:true});

// mobile touch
let touchLeft = null;   // {id, x,y, sx,sy}
let touchRight = null;  // {id, x,y}
let twoFinger = false;
let lastTwoY = 0;

function findTouch(touches, id){
  for(const t of touches) if(t.identifier === id) return t;
  return null;
}

addEventListener('touchstart', (e)=>{
  if(e.touches.length >= 2){
    twoFinger = true;
    lastTwoY = (e.touches[0].clientY + e.touches[1].clientY)/2;
  }
  for(const t of e.changedTouches){
    const isLeft = t.clientX < innerWidth*0.5;
    if(isLeft && !touchLeft){
      touchLeft = { id: t.identifier, sx: t.clientX, sy: t.clientY, x: t.clientX, y: t.clientY };
    } else if(!isLeft && !touchRight){
      touchRight = { id: t.identifier, x: t.clientX, y: t.clientY };
    }
  }
},{passive:true});

addEventListener('touchmove', (e)=>{
  if(e.touches.length >= 2){
    twoFinger = true;
    const cy = (e.touches[0].clientY + e.touches[1].clientY)/2;
    const dy = cy - lastTwoY;
    lastTwoY = cy;
    // 2 dedos: sobe/desce (bem lento)
    vel.y += (-dy) * 0.002;
  } else {
    twoFinger = false;
  }

  if(touchLeft){
    const t = findTouch(e.touches, touchLeft.id);
    if(t){
      touchLeft.x = t.clientX; touchLeft.y = t.clientY;
    }
  }
  if(touchRight){
    const t = findTouch(e.touches, touchRight.id);
    if(t){
      const dx = t.clientX - touchRight.x;
      const dy = t.clientY - touchRight.y;
      touchRight.x = t.clientX; touchRight.y = t.clientY;
      yaw   -= dx * LOOK_SENS;
      pitch -= dy * LOOK_SENS;
      pitch = clamp(pitch, -1.25, 1.25);
    }
  }
},{passive:true});

addEventListener('touchend', (e)=>{
  for(const t of e.changedTouches){
    if(touchLeft && t.identifier === touchLeft.id) touchLeft = null;
    if(touchRight && t.identifier === touchRight.id) touchRight = null;
  }
  if(e.touches.length < 2) twoFinger = false;
},{passive:true});

/* =========================
   ANIMATION LOOP
========================= */
const clock = new THREE.Clock();

function animate(){
  const dt = Math.min(0.033, clock.getDelta()); // limita dt (estável)
  const time = clock.elapsedTime;

  // heart pulse
  const pulse = 1 + Math.sin(time*2.0) * 0.02;
  heartMesh.scale.setScalar(2.2 * pulse);

  // subtle heart rotation like print
  heartMesh.rotation.y = Math.sin(time*0.25)*0.15;

  // aura slow motion
  aura.rotation.y += dt * 0.12;
  aura.rotation.x = Math.sin(time*0.12)*0.05;

  // falling particles
  const p = falling.geometry.attributes.position.array;
  const v = falling.geometry.userData.vel;
  for(let i=0;i<v.length;i++){
    const idx = i*3;
    p[idx+1] -= v[i] * dt * 2.0;
    // drift
    p[idx+0] += Math.sin(time + i)*0.0008;
    p[idx+2] += Math.cos(time + i)*0.0008;

    if(p[idx+1] < -4.8){
      p[idx+0] = (Math.random()-0.5)*1.9;
      p[idx+1] = 2.2 + Math.random()*1.6;
      p[idx+2] = (Math.random()-0.5)*1.9;
      v[i] = 0.6 + Math.random()*1.2;
    }
  }
  falling.geometry.attributes.position.needsUpdate = true;

  // rings rotation (degrees/s -> rad/s)
  for(const r of rings){
    r.rotation.y += dt * (r.userData.speed * Math.PI/180);
  }

  // build forward/right vectors from yaw/pitch
  const cosP = Math.cos(pitch);
  const sinP = Math.sin(pitch);
  const sinY = Math.sin(yaw);
  const cosY = Math.cos(yaw);

  const forward = new THREE.Vector3(-sinY * cosP, sinP, -cosY * cosP).normalize(); // W = frente
  const right   = new THREE.Vector3(cosY, 0, -sinY).normalize();

  // desired accel
  const accel = new THREE.Vector3();
  if(!isMobile){
    if(keys['w']) accel.add(forward);
    if(keys['s']) accel.addScaledVector(forward, -1);
    if(keys['d']) accel.add(right);
    if(keys['a']) accel.addScaledVector(right, -1);
    if(keys['e']) accel.y += 1;
    if(keys['q']) accel.y -= 1;
  } else {
    // mobile left joystick
    if(touchLeft){
      const dx = (touchLeft.x - touchLeft.sx);
      const dy = (touchLeft.y - touchLeft.sy);
      const max = 70;
      const nx = clamp(dx/max, -1, 1);
      const ny = clamp(dy/max, -1, 1);

      // ny positivo = dedo pra baixo => andar pra trás; então invertido
      accel.addScaledVector(forward, -ny);
      accel.addScaledVector(right, nx);
    }
  }

  if(accel.lengthSq() > 0){
    accel.normalize();
    vel.addScaledVector(accel, MOVE_ACCEL * dt);
  }

  // damping
  vel.x -= vel.x * MOVE_DAMP * dt;
  vel.y -= vel.y * MOVE_DAMP * dt;
  vel.z -= vel.z * MOVE_DAMP * dt;

  // clamp max speed
  const horiz = new THREE.Vector3(vel.x, 0, vel.z);
  const hs = horiz.length();
  if(hs > MOVE_MAX){
    horiz.multiplyScalar(MOVE_MAX / hs);
    vel.x = horiz.x; vel.z = horiz.z;
  }
  vel.y = clamp(vel.y, -MOVE_MAX, MOVE_MAX);

  // move camera
  camera.position.addScaledVector(vel, 1.0);

  // keep camera not too close to heart (avoid clipping)
  const distToHeart = camera.position.distanceTo(heartMesh.position);
  if(distToHeart < 2.8){
    const push = camera.position.clone().sub(heartMesh.position).normalize().multiplyScalar(2.8);
    camera.position.copy(heartMesh.position.clone().add(push));
    vel.multiplyScalar(0.2);
  }

  // set camera orientation
  camera.rotation.set(pitch, yaw, 0, 'YXZ');

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* =========================
   RESIZE
========================= */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
